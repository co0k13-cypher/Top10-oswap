# Exploiting insecure deserialization vulnerabilities.

## How to identify insecure deserialization.

- Trong quá trình kiểm tra, bạn nên xem xét tất cả dữ liệu đang được chuyển vào trang web và cố gắng xác định bất kỳ thứ gì giống như dữ liệu được serialization. Dữ liệu được serialization có thể được xác định tương đối dễ dàng nếu bạn biết định dạng mà các ngôn ngữ khác nhau sử dụng. Sau khi xác định được dữ liệu được tuần tự hóa, bạn có thể kiểm tra xem mình có khả năng kiểm soát dữ liệu đó hay không.

## PHP serialization format.

- PHP sử dụng định dạng chuỗi con người có thể đọc được, với các chữ cái đại diện cho kiểu dữ liệu và số đại diện cho độ dài của mỗi chuỗi. 
- VD: User object có các thuộc tính:
```
$user->name = "carlos";
$user->isLoggedIn = true;
```
Serialization:

> O:4:"User":2:{s:4:"name":s:6:"carlos"; s:10:"isLoggedIn":b:1;}
```
O:4:"User" - Một đối tượng có tên "User", 4 kí tự.
2 - đối tượng có 2 thuộc tính.
s:4:"name"- Khóa của thuộc tính đầu tiên là "name", chuỗi 4 ký tự.
s:6:"carlos" - Giá trị của thuộc tính đầu tiên là "carlos", chuỗi 6 ký tự.
s:10:"isLoggedIn" - Khóa của thuộc tính thứ hai là "isLoggedIn", chuỗi 10 ký tự.
b:1 - Giá trị của thuộc tính thứ hai là true, giá trị boolean. 
```

- Các phương thức PHP là serialize() và unserialize().

### Java serialization format.

- Java, sử dụng các định dạng tuần tự hóa nhị phân. Điều này khó đọc hơn, nhưng bạn vẫn có thể xác định dữ liệu được tuần tự hóa nếu biết cách nhận ra một vài dấu hiệu nhận biết. 

- VD : Các đối tượng Java được serialize luôn bắt đầu bằng các byte giống nhau, được mã hóa như *ac ed* trong hệ thập lục phân và *rO0* trong Base64.

- Bất kỳ lớp nào thực thi giao diện java.io.Serializable đều có thể được serialization và deserialization. Nếu bạn có quyền truy cập mã nguồn, hãy lưu ý đến bất kỳ mã nào sử dụng readObject() phương thức, được sử dụng để đọc và giải mã dữ liệu từ một InputStream.

## Manipulating serialized objects.

- Việc khai thác một số lỗ hổng serialized có thể dễ dàng như thay đổi một thuộc tính trong một đối tượng được Serialization. Khi trạng thái đối tượng được duy trì, bạn có thể nghiên cứu dữ liệu được tuần tự hóa để xác định và chỉnh sửa các giá trị thuộc tính thú vị. Sau đó, bạn có thể chuyển đối tượng độc hại vào trang web thông qua quá trình giải mã hóa của nó.

- Nói chung, có hai cách tiếp cận bạn có thể thực hiện khi thao tác với các đối tượng được Serialization. Bạn có thể chỉnh sửa đối tượng trực tiếp ở dạng luồng byte của nó hoặc bạn có thể viết một đoạn script ngắn bằng ngôn ngữ tương ứng để tự tạo và tuần tự hóa đối tượng mới. Cách tiếp cận thứ hai thường dễ dàng hơn khi làm việc với các định dạng tuần tự hóa nhị phân.

### Modifying object attributes.

- Khi giả mạo dữ liệu, miễn là kẻ tấn công bảo tồn một đối tượng được tuần tự hóa hợp lệ, quá trình giải mã hóa sẽ tạo ra một đối tượng phía máy chủ với các giá trị thuộc tính được sửa đổi.

- VD: Đối tượng User được serialzation để lưu trữ dữ liệu về phiên của người dùng trong cookie. Nếu kẻ tấn công phát hiện đối tượng được tuần tự hóa này trong một yêu cầu HTTP, chúng có thể giải mã nó để tìm luồng byte sau:

> O:4:"User":2:{s:8:"username";s:6:"carlos";s:7:"isAdmin";b:0;}

- Kẻ tấn công có thể chỉ cần thay đổi giá trị boolean của thuộc tính *isAdmin* thành 1(true), mã hóa lại đối tượng và ghi đè cookie hiện tại của chúng bằng giá trị đã sửa đổi này. Giả sử trang web sử dụng cookie này để kiểm tra xem người dùng hiện tại có quyền truy cập vào chức năng quản trị hay không.

```
$user = unserialize($_COOKIE);
if ($user->isAdmin === true) {
// allow access to admin interface
}
```

- Mã dễ bị tấn công này sẽ khởi tạo một đối tượng 'user' dựa trên dữ liệu từ cookie, bao gồm cả thuộc tính 'isAdmin'đã bị sửa đổi. Dữ liệu này không được kiểm tra sau đó được chuyển vào câu lệnh điều kiện và trong trường hợp này, sẽ cho phép dễ dàng leo thang đặc quyền.

- Lab:
	+ Lab: Modifying serialized objects.[exploit](exploit/lab1.py)

### Modifying data types.

- Chúng ta không chỉ sửa được giá trị của thuộc tính mà còn có thể thay đổi kiểu giữ liệu của chúng.

- Logic dựa trên PHP đặc biệt dễ bị tác động bởi kiểu thao tác này do hành vi của toán tử so sánh lỏng lẻo (==) khi so sánh các kiểu dữ liệu khác nhau.

- VD: 5 == "5" > true , 5 == "5 xxx" > true, 0 == "Example string" > true

```
$login = unserialize($_COOKIE)
if ($login['password'] == $password) {
// log in successfully
}
```
- Giả sử kẻ tấn công đã sửa đổi thuộc tính mật khẩu để nó chứa số nguyên 0 thay vì chuỗi . Miễn là mật khẩu không bắt đầu bằng một số, điều kiện sẽ luôn trả về true, cho phép bỏ qua xác thực. Lưu ý rằng điều này chỉ có thể thực hiện được vì quá trình serialized bảo toàn kiểu dữ liệu.

- Lưu ý rằng khi sửa đổi các kiểu dữ liệu trong bất kỳ định dạng đối tượng được serialization nào, điều quan trọng là phải nhớ cập nhật kiểu và độ dài trong dữ liệu. 

- Lab:
	+ Lab: Modifying serialized data types.[exploit](exploit/lab2.py)

## Using application functionality.

- Chức năng của trang web cũng có thể thực hiện các thao tác nguy hiểm đối với dữ liệu từ một đối tượng được deserialization. Trong trường hợp này, bạn có thể sử dụng tính năng insecure deserialization để truyền dữ liệu không mong muốn và tận dụng chức năng liên quan để gây thiệt hại.

Ví dụ: ảnh hồ sơ của người dùng sẽ bị xóa bằng cách truy cập vào đường dẫn tệp trong $user->image_location. Nếu  $user được tạo từ một đối tượng được serialization, kẻ tấn công có thể khai thác bằng cách chuyển đối tượng đã sửa đổi với image_location thành một đường dẫn tệp tùy ý. Xóa tài khoản người dùng của chính họ sau đó cũng sẽ xóa tệp tùy ý này.

- Lab:
	+ Lab: Using application functionality to exploit insecure deserialization.[exploit](exploit/lab3.py)

## Magic methods.

- Magic methods là một tập hợp con đặc biệt của các phương thức mà bạn không phải gọi một cách rõ ràng. Thay vào đó, chúng được gọi tự động bất cứ khi nào một sự kiện hoặc kịch bản cụ thể xảy ra. Các magic method là một đặc điểm chung của lập trình hướng đối tượng trong các ngôn ngữ khác nhau.

- Một trong những ví dụ phổ biến nhất trong PHP là __construct()__ - nó được gọi bất cứ khi nào một đối tượng của lớp được khởi tạo, tương tự như Python __init__. Thông thường, các phương thức này chứa mã để khởi tạo các thuộc tính. Tuy nhiên, các magic method có thể được các nhà phát triển tùy chỉnh để thực thi bất kỳ mã nào họ muốn.

- Các magic method được sử dụng rộng rãi và không tự nó thể hiện một lỗ hổng. Nhưng chúng có thể trở nên nguy hiểm khi mã mà chúng thực thi xử lý dữ liệu có thể kiểm soát được của kẻ tấn công, chẳng hạn như từ một đối tượng được deserialized. Điều này có thể bị kẻ tấn công khai thác để tự động gọi các phương thức trên dữ liệu được giải hóa khi các điều kiện tương ứng được đáp ứng.

- Trong Java deserialization, điều tương tự cũng áp dụng cho *ObjectInputStream.readObject()*, được sử dụng để đọc dữ liệu từ luồng byte ban đầu và về cơ bản hoạt động giống như một phương thức khởi tạo để "khởi tạo lại" một đối tượng được serialization. Tuy nhiên, Serializable cũng có thể khai báo *readObject()*  như sau:

```
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException
{
    // implementation
}
```
- *readObject()*  được khai báo theo cách chính xác này hoạt động như một phương thức ma thuật được gọi trong quá trình deserialization. Điều này cho phép lớp kiểm soát chặt chẽ hơn việc deserialization.

- [Magic method in PHP.](magic_method.md)

## Injecting arbitrary objects.

- Trong lập trình hướng đối tượng, các phương thức có sẵn cho một đối tượng được xác định bởi lớp của nó. Do đó, nếu kẻ tấn công có thể thao túng lớp đối tượng nào đang được chuyển vào dưới dạng dữ liệu tuần tự hóa, chúng có thể ảnh hưởng đến mã được thực thi và quá trình deserialization.

- Các phương pháp deserization thường không kiểm tra những gì chúng đang giải mã. Điều này có nghĩa là bạn có thể chuyển các đối tượng của bất kỳ lớp có thể tuần tự hóa nào có sẵn vào trang web và đối tượng sẽ được deserialization. 

- Tìm kiếm các lớp có chứa các magic method , sau đó kiểm tra xem có bất kỳ lớp nào trong số chúng thực hiện các thao tác nguy hiểm trên dữ liệu có thể kiểm soát được hay không. Sau đó, kẻ tấn công có thể truyền vào một đối tượng được serialization của lớp này để sử dụng magic method của nó để khai thác.

- Lab:
	+ Lab: Arbitrary object injection in PHP.[exploit](exploit/lab4)


## Gadget chains.

- "Gadget" là một đoạn mã tồn tại trong ứng dụng có thể giúp kẻ tấn công đạt được một mục tiêu cụ thể. Một gadget riêng lẻ có thể không trực tiếp làm bất cứ điều gì có hại với thông tin người dùng nhập. Bằng cách xâu chuỗi nhiều gadget lại với nhau, kẻ tấn công có thể chuyển đầu vào của chúng vào một "sink gadget" nguy hiểm, nơi nó có thể gây ra thiệt hại tối đa.

- Gadget chains không phải là một payload kẻ tấn công xây dựng mà là các mã đã tồn tại trên trang web. Điều duy nhất mà kẻ tấn công kiểm soát là dữ liệu được chuyển vào gadget. Điều này thường được thực hiện bằng cách sử dụng một magic method là invoked, đôi khi được gọi là "kick-off gadget".

### Working with pre-built gadget chains.

- Có một số công cụ có sẵn cung cấp một loạt các chuỗi đã được khai thác thành công trên các trang web khác. Ngay cả khi bạn không có quyền truy cập vào mã nguồn, bạn có thể sử dụng các công cụ này để xác định và khai thác các lỗ hổng insecure deserialization. Cách tiếp cận này có thể thực hiện được do việc sử dụng rộng rãi các thư viện có chứa các gadget có thể khai thác. 

#### ysoserial.

- Một công cụ như vậy cho Java deserialization là "ysoserial". Điều này cho phép bạn chọn một trong các chuỗi tiện ích được cung cấp cho thư viện mà bạn cho rằng ứng dụng đích đang sử dụng, sau đó chuyển vào một lệnh mà bạn muốn thực thi. Sau đó, nó tạo ra một đối tượng được serialization thích hợp dựa trên chuỗi đã chọn.

- Lab:
	+ Lab: Exploiting Java deserialization with Apache Commons.[exploit](exploit/lab5)

- URLDNS chains kích hoạt tra cứu DNS cho một URL được cung cấp. Quan trọng nhất, nó không dựa vào ứng dụng đích sử dụng một thư viện dễ bị tấn công cụ thể và hoạt động trong bất kỳ phiên bản Java nào đã biết. Điều này làm cho nó trở thành chuỗi tiện ích phổ biến nhất cho các mục đích phát hiện. 

- JRMPClient khiến máy chủ thiết lập kết nối TCP với địa chỉ IP được cung cấp. Chuỗi này có thể hữu ích trong môi trường mà tất cả lưu lượng đi qua tường lửa, bao gồm cả DNS. Bạn có thể thử tạo tải trọng bằng hai địa chỉ IP khác nhau: địa chỉ cục bộ và địa chỉ có tường lửa. Nếu ứng dụng phản hồi ngay lập tức cho một trọng tải có địa chỉ cục bộ, nhưng lại treo đối với một tải trọng có địa chỉ bên ngoài, gây ra sự chậm trễ trong phản hồi, điều này cho thấy rằng gadget chains đã hoạt động vì máy chủ đã cố gắng kết nối với địa chỉ có tường lửa.

#### PHP Generic Gadget Chains (PHPGGC).

- Điều quan trọng là việc giải mã dữ liệu do người dùng kiểm soát, không phải là sự hiện diện đơn thuần của một gadget chains trong mã của trang web hoặc bất kỳ thư viện nào của nó. Chuỗi tiện ích chỉ là một phương tiện điều khiển luồng dữ liệu có hại sau khi nó đã được đưa vào. 

- Lab:
	+ Lab: Exploiting PHP deserialization with a pre-built gadget chain.[exploit](exploit/lab6)


### Working with documented gadget chains.

- Không phải lúc nào cũng có các công cụ hỗ trợ để tạo gadget chains , nên việc tìm kiếm các POC được public trên mạng là một gợi ý đáng giá giúp cho bạn thiết lập các payload tấn công của riêng mình.

- Lab : 
	+ Lab: Exploiting Ruby deserialization using a documented gadget chain.[exploit](exploit/lab7)


## Creating your own exploit.

- Để xây dựng thành công gadget chains của riêng bạn, bạn gần như chắc chắn sẽ cần quyền truy cập mã nguồn. Bước đầu tiên là nghiên cứu mã nguồn này để xác định một lớp có chứa một magic method được gọi trong quá trình giải mã hóa. Đánh giá mã mà phương pháp ma thuật này thực thi để xem liệu nó có trực tiếp gây ra bất kỳ điều gì nguy hiểm với các thuộc tính do người dùng kiểm soát hay không. Điều này luôn luôn đáng để kiểm tra đề phòng.

- Nếu magic method không thể tự khai thác được, nó có thể đóng vai trò là "tiện ích khởi động" của bạn cho một gadget chains. Nghiên cứu bất kỳ phương pháp nào mà tiện ích khởi động sử dụng. Có bất kỳ hành động nào trong số này làm điều gì đó nguy hiểm với dữ liệu mà bạn kiểm soát không? Nếu không, hãy xem xét kỹ hơn từng phương thức mà chúng sau đó gọi ra, v.v.

- Khi bạn đã tìm ra cách tạo thành công gadget chains trong mã ứng dụng, bước tiếp theo là tạo một đối tượng được tuần tự hóa chứa tải trọng của bạn. Đây chỉ đơn giản là một trường hợp nghiên cứu khai báo lớp trong mã nguồn và tạo một đối tượng được tuần tự hóa hợp lệ với các giá trị thích hợp cần thiết cho việc khai thác của bạn. Như chúng ta đã thấy trong các phòng thí nghiệm trước, điều này tương đối đơn giản khi làm việc với các định dạng tuần tự hóa dựa trên chuỗi.

- Lab :
	+ Lab: Developing a custom gadget chain for PHP deserialization.[exploit](exploit/lab8)
	+ Lab: Developing a custom gadget chain for JAVA deserialization.


## PHAR deserialization.

- PHP cung cấp một số trình bao bọc kiểu URL mà bạn có thể sử dụng để xử lý các giao thức khác nhau khi truy cập đường dẫn tệp. Một trong số đó là **phar://**, cung cấp giao diện luồng để truy cập các tệp *.phar* PHP Archive ().

- PHAR là các tệp kê khai chứa siêu dữ liệu được tuần tự hóa. Điều quan trọng, nếu bạn thực hiện bất kỳ hoạt động hệ thống tệp nào trên một *phar://*, thì siêu dữ liệu này sẽ được giải mã hóa hoàn toàn. Điều này có nghĩa là một *phar://* luồng có thể là một vectơ để khai thác quá trình insecure deserialization, miễn là bạn có thể chuyển luồng này vào một phương thức hệ thống tệp.

- Các chức năng nguy hiểm như *include()* hoặc *fopen()* có thể đươc web bảo vệ. Tuy nhiên, *file_exists()*, không quá nguy hiểm, có thể không được bảo vệ.

- Kỹ thuật này cũng yêu cầu bạn tải *PHAR* lên máy chủ bằng cách nào đó. Một cách tiếp cận là sử dụng chức năng tải lên hình ảnh. Nếu bạn có thể tạo ra một tệp *PHAR* giả mạo JPG, đôi khi bạn có thể bỏ qua kiểm tra xác thực của trang web. Sau đó, nếu bạn có thể buộc trang web tải tệp gải mạo "JPG" từ một *phar://* luồng, thì mọi dữ liệu có hại mà bạn đưa vào qua *PHAR* sẽ được giải mã. Vì phần mở rộng tệp không được chọn khi PHP đọc một luồng, nên việc tệp sử dụng phần mở rộng hình ảnh không quan trọng.

- Miễn là lớp của đối tượng được trang web hỗ trợ, cả phương thức__wakeup()__ và __destruct()__ đều có thể được gọi theo cách này, cho phép bạn có khả năng khởi động gadget chains.

- Lab:


## Exploiting deserialization using memory corruption.