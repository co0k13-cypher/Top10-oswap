# How to identify and exploit HTTP Host header vulnerabilities.

## How to test for vulnerabilities using the HTTP Host header.

### Supply an arbitrary Host header.

- Khi kiểm tra các lỗ hổng chèn vào tiêu đề Máy chủ, bước đầu tiên là kiểm tra điều gì sẽ xảy ra khi bạn cung cấp một tên miền tùy ý.

- Một số proxy chặn lấy trực tiếp địa chỉ IP mục tiêu từ *HTTP Host Header*, điều này làm cho loại kiểm tra này không thể thực hiện được; bất kỳ thay đổi nào bạn thực hiện đối với tiêu đề sẽ chỉ khiến yêu cầu được gửi đến một địa chỉ IP hoàn toàn khác.

- Đôi khi, bạn vẫn có thể truy cập trang web mục tiêu ngay cả khi bạn cung cấp *HTTP Host Header* không mong muốn. 

- Mặt khác, vì *HTTP Host Header* là một phần cơ bản của cách trang web hoạt động, nên việc giả mạo nó thường có nghĩa là bạn sẽ không thể tiếp cận ứng dụng mục tiêu. Máy chủ front-end hoặc bộ cân bằng tải đã nhận được yêu cầu của bạn có thể chỉ đơn giản là không biết nơi chuyển tiếp nó, dẫn đến *Invalid Host header*. Điều này đặc biệt có thể xảy ra nếu mục tiêu của bạn được truy cập qua CDN.

### Check for flawed validation.

- Thay vì nhận được *Invalid Host Header*, bạn có thể thấy rằng yêu cầu của mình bị chặn do một số loại biện pháp bảo mật. Ví dụ: một số trang web sẽ xác thực xem tiêu đề Máy chủ có khớp với SNI từ quá trình bắt tay TLS hay không. Điều này không nhất thiết có nghĩa là chúng miễn nhiễm với các cuộc tấn công tiêu đề Máy chủ.

- Bạn cần hiểu cách trang web phân tích cú pháp *HTTP Host Header*. Điều này đôi khi có thể tiết lộ các sơ hở có thể được sử dụng để vượt qua quá trình xác thực.

- Ví dụ: 
	+ Một số thuật toán phân tích cú pháp sẽ bỏ qua cổng khỏi tiêu đề Máy chủ lưu trữ.
	```
	GET /example HTTP/1.1
	Host: vulnerable-website.com:bad-stuff-here
	``` 
	+ Các trang web khác sẽ cố gắng áp dụng logic đối sánh để cho phép các miền phụ tùy ý.
	```
	GET /example HTTP/1.1
	Host: notvulnerable-website.com
	``` 

### Send ambiguous requests.

- Bằng cách xác định và khai thác sự khác biệt về cách chúng truy xuất Host Header, bạn có thể đưa ra một yêu cầu không rõ ràng dường như có một máy chủ khác tùy thuộc vào hệ thống đang xem xét nó.

#### Inject duplicate Host headers.

- Một cách tiếp cận khả thi là thử thêm các *HTTP Host Header* trùng lặp, điều này thường sẽ dẫn đến việc yêu cầu của bạn bị chặn. Tuy nhiên, vì một trình duyệt không có khả năng gửi một yêu cầu như vậy, nên đôi khi bạn có thể thấy rằng các nhà phát triển đã không lường trước được trường hợp này.

- Các hệ thống và công nghệ khác nhau sẽ xử lý trường hợp này theo cách khác nhau, nhưng một trong hai tiêu đề thường được ưu tiên hơn tiêu đề còn lại, có hiệu quả ghi đè giá trị của nó. Khi các hệ thống không đồng ý về tiêu đề nào là tiêu đề chính xác, điều này có thể dẫn đến sự khác biệt mà bạn có thể khai thác được.

```
GET /example HTTP/1.1
Host: vulnerable-website.com
Host: bad-stuff-here
```

- Giả sử front-end ưu tiên tiêu đề đầu tiên, nhưng back-end ưu tiên tiêu đề cuối cùng. Với trường hợp này, bạn có thể sử dụng tiêu đề đầu tiên để đảm bảo rằng yêu cầu của bạn được chuyển đến mục tiêu đã định và sử dụng tiêu đề thứ hai để chuyển tải trọng của bạn vào mã phía máy chủ.

#### Supply an absolute URL.

- Mặc dù request chỉ định một đường dẫn tương đối trên miền được yêu cầu, nhiều máy chủ cũng được định cấu hình để hiểu các yêu cầu URL tuyệt đối.

- Sự không rõ ràng do cung cấp cả URL tuyệt đối và tiêu đề Máy chủ lưu trữ cũng có thể dẫn đến sự khác biệt giữa các hệ thống khác nhau. Về mặt chính thức, dòng yêu cầu nên được ưu tiên khi định tuyến yêu cầu nhưng trên thực tế, điều này không phải lúc nào cũng đúng. Bạn có thể khai thác sự khác biệt này theo cách giống như các tiêu đề Máy chủ lưu trữ trùng lặp.
```
GET https://vulnerable-website.com/ HTTP/1.1
Host: bad-stuff-here
```

#### Add line wrapping.

- Bạn cũng có thể phát hiện điều bất thường bằng cách thụt lề các tiêu đề HTTP với một ký tự khoảng trắng. Một số máy chủ sẽ hiểu tiêu đề thụt vào là một dòng được bao bọc và do đó, coi nó như một phần của giá trị của tiêu đề trước đó. Các máy chủ khác sẽ hoàn toàn bỏ qua tiêu đề thụt lề.
```
GET /example HTTP/1.1
    Host: bad-stuff-here
Host: vulnerable-website.com
```

### Inject host override headers.

- Ngay cả khi bạn không thể ghi đè *HTTP Host Header* bằng cách sử dụng một yêu cầu không rõ ràng, vẫn có những khả năng khác để ghi đè giá trị của nó trong khi vẫn giữ nguyên giá trị của nó. Điều này bao gồm việc chèn payload qua một trong số các tiêu đề HTTP khác được thiết kế để phục vụ mục đích này.

- Các trang web thường được truy cập thông qua một số loại hệ thống trung gian, chẳng hạn như bộ cân bằng tải hoặc proxy ngược. *HTTP Host Header* mà máy chủ back-end nhận được có thể chứa tên miền cho một trong các hệ thống trung gian này.

- Để giải quyết vấn đề này, giao diện người dùng có thể sử dụng *X-Forwarded-Host*, chứa giá trị ban đầu của *HTTP Host Header* từ yêu cầu ban đầu. 

```
GET /example HTTP/1.1
Host: vulnerable-website.com
X-Forwarded-Host: bad-stuff-here
```
- Một số header khác:
```
X-Host
X-Forwarded-Server
X-HTTP-Host-Override
Forwarded
```

## How to exploit the HTTP Host header.

### [Password reset poisoning.](pass_reset.md)

### Web cache poisoning via the Host header.

- Khi kiểm tra các cuộc tấn công Host Header, bạn thường sẽ bắt gặp hành vi dường như dễ bị tấn công mà không thể khai thác trực tiếp. Tuy nhiên, nếu mục tiêu sử dụng bộ nhớ cache web có thể tồn tại một lỗ hổng nguy hiểm.

- Để thực hiện một cuộc tấn công nhiễm độc bộ nhớ cache web, cần phải có một phản hồi từ máy chủ phản ánh payload được đưa vào. Thách thức là làm được điều này trong khi vẫn bảo toàn khóa bộ nhớ cache được ánh xạ tới các yêu cầu của người dùng khác. Nếu thành công, bước tiếp theo là đưa phản hồi độc hại này vào bộ nhớ đệm. Sau đó, nó sẽ được thực thi cho bất kỳ người dùng nào truy cập trang bị ảnh hưởng.

- Bộ nhớ đệm độc lập thường bao gồm tiêu đề Máy chủ lưu trữ trong khóa bộ nhớ cache, do đó, cách tiếp cận này thường hoạt động tốt nhất trên bộ nhớ đệm cấp ứng dụng, được tích hợp.

- Lab: 
	+ Lab: Web cache poisoning via ambiguous requests.[exploit](exploit/lab3.py)

### Exploiting classic server-side vulnerabilities.

### Accessing restricted functionality.

- Thông thường các trang web chỉ giới hạn quyền truy cập vào một số chức năng cho người dùng nội bộ. Tuy nhiên, các tính năng kiểm soát truy cập của một số trang web đưa ra các giả định sai sót cho phép bạn bỏ qua các hạn chế này bằng cách thực hiện các sửa đổi đơn giản đối với tiêu đề Máy chủ.

- Lab: Host header authentication bypass.[exploit](exploit/lab4.py)

### Accessing internal websites with virtual host brute-forcing.

- Khi lưu trữ các trang web có thể truy cập công cộng và các trang riêng tư, nội bộ trên cùng một máy chủ. Máy chủ thường có cả địa chỉ IP công cộng và riêng tư. Vì tên máy chủ nội bộ có thể phân giải thành địa chỉ IP riêng, nên không thể phát hiện bằng cách xem các bản ghi DNS:
```
www.example.com: 12.34.56.78
intranet.example.com: 10.0.0.132
```
- Trong một số trường hợp, trang web nội bộ thậm chí có thể không có bản ghi DNS công cộng được liên kết với nó. Tuy nhiên, kẻ tấn công thường có thể truy cập vào bất kỳ máy chủ ảo nào mà chúng có quyền truy cập, miễn là chúng có thể đoán được tên máy chủ. Nếu họ phát hiện ra một tên miền ẩn thông qua các phương tiện khác, chẳng hạn như tiết lộ thông tin.

### Routing-based SSRF.

- Các lỗ hổng SSRF thường dựa trên XXE hoặc logic nghiệp vụ có thể khai thác gửi các yêu cầu HTTP đến một URL bắt nguồn từ đầu vào do người dùng kiểm soát. Mặt khác, SSRF dựa trên định tuyến phụ thuộc vào việc khai thác các thành phần trung gian phổ biến trong nhiều kiến ​​trúc dựa trên đám mây.

- Mặc dù các thành phần này được triển khai cho các mục đích khác nhau, nhưng về cơ bản, chúng nhận được yêu cầu và chuyển tiếp chúng đến back-end. Nếu chúng được định cấu hình không an toàn để chuyển tiếp các yêu cầu dựa trên *HTTP Host Header*, chúng có thể bị chuyển thành các yêu cầu định tuyến sai đến một hệ thống tùy ý.

- Sau khi xác nhận rằng bạn có thể thao túng thành công một hệ thống trung gian để định tuyến các yêu cầu của bạn đến một máy chủ tùy ý, bước tiếp theo là xem liệu bạn có thể khai thác hành vi này để truy cập các hệ thống nội bộ hay không. Để làm điều này, bạn sẽ cần xác định các địa chỉ IP riêng đang được sử dụng trên mạng nội bộ của mục tiêu. Ngoài bất kỳ địa chỉ IP nào bị rò rỉ bởi ứng dụng, bạn cũng có thể quét tên máy chủ của công ty để xem có giải pháp nào đối với địa chỉ IP riêng hay không. Nếu vẫn thất bại, bạn vẫn có thể xác định các địa chỉ IP hợp lệ bằng cách đơn giản ép buộc các dải IP riêng tiêu chuẩn, chẳng hạn như 192.168.0.0/16.

- Lab: 
	+ Lab: Routing-based SSRF.[exploit](exploit/lab5.py)
	+ Lab: SSRF via flawed request parsing.[exploit](exploit/lab6.py)


#### SSRF via a malformed request line.



